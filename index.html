<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>KiwiPong</title>
  <style>
    :root{
      --bg1:#0a1f44; /* azul profundo */
      --bg2:#0f4c81; /* azul medio */
      --accent:#38b6ff; /* cian acento */
      --accent-2:#78d1ff; /* cian claro */
      --card:#0b2a55ee;
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --radius:22px;
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html,body{ height:100%; margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial; background: radial-gradient(1200px 800px at 50% 10%, #11396f, var(--bg1)) fixed; color:white; }
    .wrap{ position:relative; height:100%; display:grid; place-items:center; padding:14px; }

    .phone-frame{ width:min(100%, 520px); aspect-ratio:9/16; border-radius: calc(var(--radius) + 8px); padding:12px; background: linear-gradient(160deg, #001a3a, #032a57 60%, #083c7a); box-shadow: var(--shadow), inset 0 0 0 1px rgba(255,255,255,.06); position:relative; }

    .statusbar{ position:absolute; top:8px; left:12px; right:12px; display:flex; gap:10px; align-items:center; justify-content:space-between; pointer-events:none; }
    .badge{ pointer-events:auto; backdrop-filter: blur(6px); background: linear-gradient(180deg, #0e2f66ee, #0b2553dd); border:1px solid rgba(255,255,255,.08); border-radius:999px; padding:6px 12px; box-shadow: 0 6px 16px rgba(0,0,0,.25), inset 0 0 18px rgba(56,182,255,.18); display:flex; gap:10px; align-items:center; }
    .badge strong{ letter-spacing:.4px; }
    .controls{ display:flex; gap:8px; }
    .btn{ pointer-events:auto; cursor:pointer; background: linear-gradient(180deg, #1a5bb3, #0f4c81); border:1px solid rgba(255,255,255,.14); color:white; padding:8px 12px; border-radius:999px; box-shadow: 0 8px 18px rgba(0,0,0,.3), inset 0 0 20px rgba(120,209,255,.2); font-weight:700; letter-spacing:.3px; transition: transform .05s ease; user-select:none; }
    .btn:active{ transform: translateY(1px) scale(.99); }

    .board{ position:relative; width:100%; height:100%; border-radius: var(--radius); overflow:hidden; background:
      radial-gradient(600px 700px at 50% -20%, rgba(56,182,255,.28), transparent 60%),
      linear-gradient(180deg, rgba(8,34,80,.85), rgba(5,21,52,.95));
      box-shadow: inset 0 0 0 1px rgba(56,182,255,.2), inset 0 0 60px rgba(56,182,255,.06), inset 0 0 160px rgba(56,182,255,.08);
    }

    canvas{ position:absolute; inset:0; width:100%; height:100%; display:block; }

    .overlay{ position:absolute; inset:0; display:grid; place-items:center; padding:18px; }
    .card{ background: linear-gradient(180deg, #0d2e62ee, #0a2250f2); border: 1px solid rgba(255,255,255,.10); border-radius: var(--radius); padding:22px; width:min(92%, 420px); text-align:center; box-shadow: var(--shadow), inset 0 0 32px rgba(56,182,255,.12); }
    .title{ font-size: clamp(20px, 3.6vw, 28px); font-weight:800; margin-bottom:8px; letter-spacing:.3px; }
    .subtitle{ opacity:.9; line-height:1.4; margin-bottom:16px; }
    .cta{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }
    .cta .btn{ font-size:16px; padding:10px 16px; }

    .touchbar{ position:absolute; left:0; right:0; bottom:0; padding:14px; display:flex; justify-content:center; pointer-events:none; }
    .hint{ pointer-events:auto; background: linear-gradient(180deg, #0a2a58dd, #081f45dd); border:1px solid rgba(255,255,255,.08); border-radius:999px; padding:10px 16px; font-size:14px; opacity:.9; }

    .score{ font-variant-numeric: tabular-nums; }

    .divider{ position:absolute; top:50%; left:10%; right:10%; height:1px; background: linear-gradient(90deg, transparent, rgba(120,209,255,.5), transparent); filter: drop-shadow(0 0 6px rgba(120,209,255,.5)); opacity:.25; }

    /* Prevent text selection during fast drags */
    .board, .btn, .hint { -webkit-user-select:none; -ms-user-select:none; user-select:none; }

    /* ADICI√ìN previa: evita scroll/zoom durante el arrastre t√°ctil */
    .board, .board canvas { touch-action: none; }
    /* --- FIX: que el marcador quede encima del juego --- */
    .statusbar { z-index: 10; }
    .board     { z-index: 1;  }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="phone-frame">
      <div class="statusbar">
        <div class="badge"><strong>üéÆ KiwiPong</strong> <span class="score" id="score">0 ‚Äî 0</span></div>
        <div class="controls">
          <button class="btn" id="pauseBtn">‚è∏Ô∏é Pause</button>
          <button class="btn" id="resetBtn">‚Ü∫ Restart</button>
        </div>
      </div>
      <div class="board" id="board">
        <div class="divider"></div>
        <canvas id="game"></canvas>
        <div class="overlay" id="overlay">
          <div class="card">
            <div class="title">Kiwipong</div>
            <div class="subtitle">Drag your finger <b>left ‚Üî right</b> for moving your padle. Beat Grey. Win the one that wins 7 points.
              The ball will get faster as the point progresses.</div>
            <div class="cta">
              <button class="btn" id="startBtn">‚ñ∂Ô∏è Play</button>
              <button class="btn" id="howBtn">‚ùì How to play</button>
            </div>
          </div>
        </div>
        <div class="touchbar"><div class="hint">Tip: Mantain your finger in the middle. </div></div>
      </div>
    </div>
  </div>

  <script>
  (function(){
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const board = document.getElementById('board');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');
    const howBtn = document.getElementById('howBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');
    const scoreEl = document.getElementById('score');

    let W=0,H=0, DPR= Math.max(1, Math.min(2, window.devicePixelRatio||1));

    function fit(){
      const rect = board.getBoundingClientRect();
      W = Math.floor(rect.width); H = Math.floor(rect.height);
      const w = Math.floor(W * DPR), h = Math.floor(H * DPR);
      canvas.width = w; canvas.height = h; canvas.style.width=W+"px"; canvas.style.height=H+"px";
      ctx.setTransform(DPR,0,0,DPR,0,0);
      trailAlpha = 0.22; // refresh trail after resize
    }
    new ResizeObserver(fit).observe(board);

    // --- Game State ---
    const state = {
      running:false,
      paused:false,
      playerScore:0,
      aiScore:0,
      level:1,
    };

    const PADDLE = { wRatio:0.22, h:14, radius:8, speed: 9 }; // px per frame (logical)
    const BALL = { r:8, speed: 6.5, maxSpeed: 10, spin: 0.18 };
    let player = { x:0, y:0, w:0, h:PADDLE.h, vx:0 };
    let ai = { x:0, y:0, w:0, h:PADDLE.h, vx:0 };
    let ball = { x:0, y:0, vx:0, vy:0, r:BALL.r };

    let lastTime=0, animId=null, trailAlpha=0.22;
    let touchX=null, dragging=false;

    function resetPositions(){
      player.w = Math.max(60, W * PADDLE.wRatio);
      ai.w = player.w;
      player.x = (W - player.w)/2; player.y = H - (H*0.12);
      ai.x = (W - ai.w)/2; ai.y = (H*0.12) - ai.h;
      player.vx = ai.vx = 0;
      ball.x = W/2; ball.y = H/2;
      const angle = (Math.random() * 0.7 + 0.15) * Math.PI; // 27¬∞- 117¬∞
      const dir = Math.random()<0.5? -1:1; // hacia arriba o abajo
      ball.vx = Math.cos(angle) * BALL.speed * (Math.random()<0.5? -1:1);
      ball.vy = Math.sin(angle) * BALL.speed * dir;
    }

    function start(){
      state.running = true; state.paused=false; overlay.style.display='none';
      scoreEl.textContent = `${state.playerScore} ‚Äî ${state.aiScore}`;
      if(!animId){ lastTime=performance.now(); animId = requestAnimationFrame(loop); }
      if(navigator.vibrate) navigator.vibrate(10);
    }
    function pause(){ state.paused = !state.paused; pauseBtn.textContent = state.paused? '‚ñ∂Ô∏è Continue':'‚è∏Ô∏é Pause'; }
    function reset(){ state.playerScore=0; state.aiScore=0; state.level=1; scoreEl.textContent = `0 ‚Äî 0`; resetPositions(); trailAlpha=0.22; }

    /* === ADICI√ìN previa: ignorar eventos al tocar UI/overlay === */
    function isUIEvent(e){
      const t = e.target;
      if (!t) return false;
      if (getComputedStyle(overlay).display !== 'none' && overlay.contains(t)) return true;
      return !!(t.closest && t.closest('.btn, a, input, select, textarea'));
    }

    // --- Touch Controls ---
    function onTouchStart(e){ if (isUIEvent(e)) return; dragging=true; const t = e.touches[0]; touchX = t.clientX - board.getBoundingClientRect().left; e.preventDefault(); }
    function onTouchMove(e){ if (!dragging || isUIEvent(e)) return; const t = e.touches[0]; touchX = t.clientX - board.getBoundingClientRect().left; e.preventDefault(); }
    function onTouchEnd(){ dragging=false; touchX=null; }

    board.addEventListener('touchstart', onTouchStart, {passive:false});
    board.addEventListener('touchmove', onTouchMove, {passive:false});
    board.addEventListener('touchend', onTouchEnd);

    // Also allow mouse for desktop testing
    board.addEventListener('mousedown', (e)=>{ dragging=true; touchX=e.offsetX; });
    board.addEventListener('mousemove', (e)=>{ if(dragging){ touchX=e.offsetX; }});
    window.addEventListener('mouseup', ()=>{ dragging=false; touchX=null; });

    // UI Buttons
    startBtn.addEventListener('click', ()=>{ reset(); start(); });
    howBtn.addEventListener('click', ()=>{ alert('Drag your finger left ‚Üî right on the bottom half to move your paddle. Win by 7 points.'); });
    pauseBtn.addEventListener('click', ()=>{ if(state.running) pause(); });
    resetBtn.addEventListener('click', ()=>{ reset(); if(!state.running){ start(); } });

    // --- AI ---
    function aiUpdate(){
      const target = ball.x - ai.w/2; // follow ball center
      const maxStep = 5 + state.level*0.6; // harder with level
      const diff = target - ai.x;
      ai.vx = Math.max(-maxStep, Math.min(maxStep, diff));
      ai.x += ai.vx;
      ai.x = Math.max(6, Math.min(W - ai.w - 6, ai.x));
    }

    // --- Physics ---
    function update(dt){
      // Player move toward touchX
      if(touchX!=null){
        const target = touchX - player.w/2;
        const diff = target - player.x;
        player.vx = Math.max(-PADDLE.speed, Math.min(PADDLE.speed, diff));
        player.x += player.vx;
      } else {
        // friction when no input
        player.vx *= 0.9; player.x += player.vx;
      }
      player.x = Math.max(6, Math.min(W - player.w - 6, player.x));

      aiUpdate();

      // Ball movement
      ball.x += ball.vx; ball.y += ball.vy;

      // Wall collisions (left/right)
      if(ball.x - ball.r < 0){ ball.x = ball.r; ball.vx *= -1; ping(); }
      if(ball.x + ball.r > W){ ball.x = W - ball.r; ball.vx *= -1; ping(); }

      // Paddle collisions
      // Player (bottom)
      if(ball.y + ball.r >= player.y && ball.y + ball.r <= player.y + player.h + 12 && ball.x > player.x && ball.x < player.x + player.w && ball.vy>0){
        ball.y = player.y - ball.r;
        const hit = ((ball.x - (player.x + player.w/2)) / (player.w/2)); // -1..1
        ball.vy = -Math.max(4.5, Math.min(BALL.maxSpeed, Math.abs(ball.vy)+0.6 + state.level*0.2));
        ball.vx += hit * 2.6 + player.vx*0.35; // add spin + paddle motion
        limitBallSpeed();
        pulse();
      }
      // AI (top)
      if(ball.y - ball.r <= ai.y + ai.h && ball.y - ball.r >= ai.y - 12 && ball.x > ai.x && ball.x < ai.x + ai.w && ball.vy<0){
        ball.y = ai.y + ai.h + ball.r;
        const hit = ((ball.x - (ai.x + ai.w/2)) / (ai.w/2));
        ball.vy = Math.max(4.5, Math.min(BALL.maxSpeed, Math.abs(ball.vy)+0.55 + state.level*0.18));
        ball.vx += hit * 2.3 + ai.vx*0.25;
        limitBallSpeed();
        ping();
      }

      // Goals (top/bottom out)
      if(ball.y < -20){
        // Player scores
        state.playerScore++; nextRound(true);
      }
      if(ball.y > H+20){
        // AI scores
        state.aiScore++; nextRound(false);
      }
    }

    function limitBallSpeed(){
      const s = Math.hypot(ball.vx, ball.vy);
      if(s>BALL.maxSpeed){ const k = BALL.maxSpeed/s; ball.vx*=k; ball.vy*=k; }
    }

    function nextRound(playerPoint){
      scoreEl.textContent = `${state.playerScore} ‚Äî ${state.aiScore}`;
      const won = state.playerScore>=7 || state.aiScore>=7;
      if(won){
        state.running=false;
        overlay.style.display='grid';
        overlay.querySelector('.title').textContent = state.playerScore>state.aiScore? 'üèÜ ¬°Ganaste!':'üòÖ Perdiste';
        overlay.querySelector('.subtitle').innerHTML = `Marcador final <b>${state.playerScore} ‚Äî ${state.aiScore}</b> ¬∑ Toca Jugar para intentar de nuevo.`;
        if(navigator.vibrate) navigator.vibrate([50,60,50]);
        cancelAnimationFrame(animId); animId=null; return;
      }
      if(playerPoint){ if(navigator.vibrate) navigator.vibrate(25);} else { if(navigator.vibrate) navigator.vibrate([10,30,10]); }
      // Difficulty up a bit every 2 total points
      const total = state.playerScore + state.aiScore;
      state.level = 1 + Math.floor(total/2);
      resetPositions();
      trailAlpha = 0.12; // quick fade between rounds

      /* === ADICI√ìN: detener tras cada punto y esperar Play === */
      awaitingServe = true;
      state.running = false;
      overlay.style.display = 'grid';
    }

    function ping(){ /* subtle effect */ if(navigator.vibrate) navigator.vibrate(8); }
    function pulse(){ if(navigator.vibrate) navigator.vibrate([5,20,5]); }

    // --- Render ---
    function draw(){
      // Trail background
      ctx.save();
      ctx.globalAlpha = trailAlpha; // lower alpha = longer trail
      const g = ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0,'#06224e'); g.addColorStop(1,'#041a3d');
      ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
      ctx.restore();

      // Center glow
      const rad = ctx.createRadialGradient(W/2,H/2,10, W/2,H/2, Math.max(W,H));
      rad.addColorStop(0,'rgba(56,182,255,0.07)');
      rad.addColorStop(1,'rgba(56,182,255,0)');
      ctx.fillStyle = rad; ctx.fillRect(0,0,W,H);

      // Net dots
      ctx.save();
      ctx.globalAlpha = .18; ctx.fillStyle = '#78d1ff';
      for(let x=12;x<W-12;x+=18){ ctx.fillRect(x, H/2-1, 6, 2); }
      ctx.restore();

      // Paddles
      const padGrad = ctx.createLinearGradient(0,0,0,player.h);
      padGrad.addColorStop(0,'#5fc0ff'); padGrad.addColorStop(1,'#0f66b8');
      ctx.fillStyle = padGrad;
      ctx.shadowColor = 'rgba(120,209,255,.65)'; ctx.shadowBlur = 18;
      roundRect(ctx, player.x, player.y, player.w, player.h, 8);
      roundRect(ctx, ai.x, ai.y, ai.w, ai.h, 8);

      // Ball
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
      const ballGrad = ctx.createRadialGradient(ball.x-2, ball.y-2, 1, ball.x, ball.y, ball.r+6);
      ballGrad.addColorStop(0,'#ffffff'); ballGrad.addColorStop(1,'#38b6ff');
      ctx.fillStyle = ballGrad; ctx.fill();
      ctx.shadowColor = 'rgba(120,209,255,.85)'; ctx.shadowBlur = 26;
      ctx.strokeStyle = 'rgba(56,182,255,.6)'; ctx.lineWidth = 1.2; ctx.stroke();
      ctx.shadowBlur = 0;
    }

    function roundRect(ctx, x, y, w, h, r){
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath(); ctx.fill();
    }

    function loop(t){
      animId = requestAnimationFrame(loop);
      if(state.paused || !state.running){ return; }
      const dt = Math.min(32, t - lastTime); lastTime = t;
      // Slightly reduce trails over time during gameplay
      trailAlpha = Math.max(0.08, trailAlpha - 0.0006*dt);
      update(dt);
      draw();
    }

    // Initialize
    fit(); resetPositions();
    // Show start overlay initially

    // For orientation changes
    window.addEventListener('orientationchange', ()=>{ setTimeout(()=>{ fit(); resetPositions(); }, 200); });

    /* === ADICI√ìN: soporte Pointer Events en m√≥viles === */
    if (window.PointerEvent) {
      board.addEventListener('pointerdown', (e) => {
        if (!(e.pointerType === 'touch' || e.pointerType === 'pen')) return;
        if (isUIEvent(e)) return;
        dragging = true;
        const rect = board.getBoundingClientRect();
        touchX = e.clientX - rect.left;
        try { board.setPointerCapture(e.pointerId); } catch {}
        e.preventDefault();
      }, { passive: false });

      board.addEventListener('pointermove', (e) => {
        if (!dragging) return;
        if (isUIEvent(e)) return;
        const rect = board.getBoundingClientRect();
        touchX = e.clientX - rect.left;
        e.preventDefault();
      }, { passive: false });

      const stopPointer = (e) => {
        dragging = false; touchX = null;
        try { if (e && e.pointerId != null) board.releasePointerCapture(e.pointerId); } catch {}
      };
      board.addEventListener('pointerup', stopPointer);
      board.addEventListener('pointercancel', stopPointer);
      board.addEventListener('lostpointercapture', stopPointer);
    }

    /* === ADICI√ìN: flag de ‚Äúesperando saque‚Äù y captura del click en Play === */
    let awaitingServe = false;

    // Capturamos el click ANTES que tu listener original (fase capture)
    startBtn.addEventListener('click', (e) => {
      if (!awaitingServe) return;              // si no estamos entre puntos, deja que haga reset+start
      e.preventDefault();
      e.stopImmediatePropagation();            // evita que se dispare el reset original
      awaitingServe = false;
      overlay.style.display = 'none';
      state.paused = false;
      state.running = true;
      if(navigator.vibrate) navigator.vibrate(10);
      // el loop ya est√° activo; nextRound() dej√≥ posiciones listas
    }, { capture: true });

  })();
  </script>
</body>
</html>
